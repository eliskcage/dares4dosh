<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>SHORTFACTORY ‚Äî CORTEX</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    color: #fff;
  }

  .container {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .ai-response {
    font-size: clamp(0.84rem, 2.8vw, 1.75rem);
    line-height: 1.6;
    text-align: center;
    margin-bottom: 60px;
    max-width: 800px;
    animation: fadeIn 0.5s ease-out;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  }

  .points-display {
    position: fixed;
    top: 20px;
    right: 20px;
    font-size: 0.7rem;
    color: #fff;
    opacity: 0.6;
    text-align: right;
  }

  .points-display span {
    color: #0f0;
  }

  .value-display {
    font-size: 0.6rem;
    margin-top: 4px;
    opacity: 0.9;
    font-weight: bold;
  }

  .value-display.female {
    color: #ff1493;
  }

  .value-display.male {
    color: #00bfff;
  }

  .value-display.zombie {
    color: #228b22;
    animation: zombiePulse 2s infinite;
  }

  @keyframes zombiePulse {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; text-shadow: 0 0 10px #228b22; }
  }

  .input-container {
    display: flex;
    gap: 12px;
    width: 100%;
    max-width: 600px;
    align-items: center;
  }

  .prompt {
    color: #fff;
    font-size: 0.9rem;
    opacity: 0.6;
  }

  .input-box {
    flex: 1;
    padding: 16px 20px;
    background: #fff;
    border: none;
    color: #000;
    font-family: 'Press Start 2P', monospace;
    font-size: 0.9rem;
  }

  .input-box:focus {
    outline: none;
  }

  .cursor {
    display: inline-block;
    width: 16px;
    height: 2px;
    background: #000;
    margin-left: 4px;
    animation: blink 1s infinite;
    vertical-align: middle;
  }

  @keyframes blink {
    0%, 49% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }

  .send-btn {
    padding: 16px 32px;
    background: transparent;
    color: #fff;
    border: none;
    border-bottom: 2px solid #fff;
    font-family: 'Press Start 2P', monospace;
    font-size: 0.9rem;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .send-btn:hover {
    opacity: 0.7;
  }

  .send-btn:active {
    opacity: 0.5;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Memory meters */
  .memory-meters {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 40px;
  }

  .meter {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .meter-label {
    font-size: 0.5rem;
    color: #fff;
    opacity: 0.7;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    letter-spacing: 2px;
  }

  .meter-bar {
    width: 20px;
    height: 144px;
    background: #222;
    border: 3px solid #444;
    position: relative;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
  }

  .meter-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    transition: height 0.5s ease-out;
  }

  .meter-fill.memories {
    background: linear-gradient(to top, #0f0, #0a0);
    box-shadow: 0 0 10px rgba(0,255,0,0.5);
  }

  .meter-fill.space {
    background: linear-gradient(to top, #00f, #00a);
    box-shadow: 0 0 10px rgba(0,0,255,0.5);
  }

  @keyframes meterPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; box-shadow: 0 0 20px currentColor; }
  }

  .meter-fill.pulse {
    animation: meterPulse 0.5s ease-out;
  }

  .meter-value {
    font-size: 0.4rem;
    color: #fff;
    opacity: 0.5;
    margin-top: 4px;
  }

  /* Mobile adjustments */
  @media (max-width: 600px) {
    .ai-response {
      font-size: 1rem;
      margin-bottom: 40px;
    }

    .input-box, .send-btn {
      font-size: 0.7rem;
      padding: 12px 16px;
    }

    .memory-meters {
      right: 10px;
      gap: 20px;
    }

    .meter-bar {
      height: 100px;
    }
  }
</style>
</head>
<body>

<div class="points-display">
  HP: <span id="points">0</span>
  <div class="value-display" id="valueDisplay"></div>
  <div class="crypto-status" id="cryptoStatus" onclick="connectWallet()" style="margin-top:8px;cursor:pointer;font-size:0.5rem;opacity:0.7;">
    ü¶ä CONNECT WALLET
  </div>
</div>

<div class="memory-meters">
  <div class="meter">
    <span class="meter-label">MEMORIES</span>
    <div class="meter-bar">
      <div class="meter-fill memories" id="memoriesFill"></div>
    </div>
    <span class="meter-value" id="memoriesValue">0</span>
  </div>
  <div class="meter">
    <span class="meter-label">SPACE</span>
    <div class="meter-bar">
      <div class="meter-fill space" id="spaceFill"></div>
    </div>
    <span class="meter-value" id="spaceValue">0%</span>
  </div>
</div>

<div class="container">
  <div class="ai-response" id="response">
    _
  </div>

  <div class="input-container">
    <span class="prompt">USER:</span>
    <input type="text" class="input-box" id="input" placeholder="" autocomplete="off">
    <span class="cursor" id="cursor"></span>
    <input type="file" id="fileUpload" style="display:none" onchange="handleFileUploadUI(this.files[0])">
    <button class="send-btn" onclick="document.getElementById('fileUpload').click()" style="padding:16px 24px;margin-left:8px;" title="Upload file">üìé</button>
    <button class="send-btn" id="send">></button>
  </div>
</div>

<script>
// Handle file upload UI
async function handleFileUploadUI(file) {
  if (!file) return;

  const result = await handleFileUpload(file);

  if (result.success) {
    response.innerHTML = `FILE UPLOADED<br>${file.name}<br>${result.upload.size}<br>TRUST LVL ${userTrust.level}`;
    speak('File uploaded successfully');
  } else {
    response.innerHTML = `UPLOAD FAILED<br>${result.error}<br><br>${result.upgradeMessage || ''}`;
    speak('Upload failed');
  }
}
</script>

<script>
const response = document.getElementById('response');
const input = document.getElementById('input');
const send = document.getElementById('send');
const pointsDisplay = document.getElementById('points');

const XAI_API_KEY = 'YOUR_XAI_API_KEY_HERE'; // Get from: https://console.x.ai
const XAI_ENDPOINT = 'https://api.x.ai/v1/chat/completions';

let conversationHistory = [];
let messageCount = 0;
let userPoints = parseInt(localStorage.getItem('shortfactory_points')) || 0;
let storedJokes = JSON.parse(localStorage.getItem('shortfactory_jokes')) || [];
let storedFacts = JSON.parse(localStorage.getItem('shortfactory_facts')) || [];
let storedDares = JSON.parse(localStorage.getItem('shortfactory_dares')) || [];
let userHasShared = localStorage.getItem('shortfactory_shared_fact') === 'true';
let chattyTimer = null;

// MARKETPLACE & ESCROW SYSTEM
let marketplace = JSON.parse(localStorage.getItem('shortfactory_marketplace')) || {
  listings: [], // Items/services for sale
  transactions: [], // Active escrow transactions
  completedDeals: [], // Transaction history
  aiInventory: [], // Items AI owns
  userBalance: 0 // User's cash balance ($)
};

// CRYPTO PAYMENT SYSTEM
let cryptoWallet = JSON.parse(localStorage.getItem('shortfactory_crypto')) || {
  connected: false,
  address: null,
  network: null,
  balances: {
    ETH: 0,
    BTC: 0,
    USDT: 0
  },
  transactions: [],
  pendingPayments: []
};

// TRUST-BASED SERVICE PLATFORM
let userTrust = JSON.parse(localStorage.getItem('shortfactory_trust')) || {
  level: 0, // 0=new, 1=proven, 2=trusted, 3=verified
  score: 0, // 0-1000 points
  completedJobs: 0,
  totalSpent: 0,
  deposits: [],
  verifications: {
    passport: false,
    passportAddress: 'SHORTFACTORY, Macclesfield, SK10 (Recorded Delivery)',
    email: false,
    phone: false,
    walletVerified: false
  },
  uploadLimits: {
    0: 5, // 5MB for new users
    1: 50, // 50MB for proven
    2: 500, // 500MB for trusted
    3: 5000 // 5GB for verified
  }
};

// SERVICE CATALOG
const SERVICES = {
  advertising: {
    name: 'Advertising Campaign',
    minPrice: 100,
    maxPrice: 5000,
    eta: '3-7 days',
    trustRequired: 1,
    depositPercent: 50
  },
  marketing: {
    name: 'Marketing Strategy',
    minPrice: 200,
    maxPrice: 10000,
    eta: '5-14 days',
    trustRequired: 1,
    depositPercent: 50
  },
  security: {
    name: 'Internet Security Audit',
    minPrice: 500,
    maxPrice: 20000,
    eta: '7-21 days',
    trustRequired: 2,
    depositPercent: 100 // Full deposit for security work
  },
  videoEdit: {
    name: 'Video Editing',
    minPrice: 50,
    maxPrice: 2000,
    eta: '2-5 days',
    trustRequired: 0,
    depositPercent: 30
  },
  webDesign: {
    name: 'Web Design',
    minPrice: 300,
    maxPrice: 15000,
    eta: '7-30 days',
    trustRequired: 1,
    depositPercent: 50
  },
  seo: {
    name: 'SEO Optimization',
    minPrice: 150,
    maxPrice: 3000,
    eta: '14-60 days',
    trustRequired: 1,
    depositPercent: 40
  },
  custom: {
    name: 'Custom Service',
    minPrice: 50,
    maxPrice: 50000,
    eta: 'Variable',
    trustRequired: 3, // Need verification for custom
    depositPercent: 100
  }
};

// JOB QUEUE
let jobQueue = JSON.parse(localStorage.getItem('shortfactory_jobs')) || [];

// NOTIFICATION SETTINGS
const NOTIFICATION_EMAIL = 'cortex@shortfactory.shop'; // Replace with your email
const CALENDAR_WEBHOOK = null; // Add Google Calendar webhook URL

// Escrow wallet addresses (SHORTFACTORY controlled)
const ESCROW_WALLETS = {
  ETH: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e', // Example - replace with real
  BTC: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh', // Example - replace with real
  USDT_ERC20: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e' // Same as ETH for ERC-20
};

// User profile with value metrics
let userProfile = JSON.parse(localStorage.getItem('shortfactory_profile')) || {
  gender: null, // 'male' or 'female'
  valueScore: 0, // 0-100
  toxicityScore: 0, // 0-100 (zombie meter)
  negativeTraits: {
    weird: 0,
    spiteful: 0,
    marxist: 0,
    druggie: 0,
    uncultured: 0,
    hostile: 0,
    pervy: 0,
    pedoish: 0,
    retarded: 0,
    miserable: 0,
    rude: 0,
    diseased: 0
  },
  redFlags: [], // Track specific incidents
  attributes: {
    // Female value metrics
    age: null,
    attractiveness: 0,
    single: null,
    purity: 0,
    personality: 0,
    // Male value metrics
    wealth: 0,
    looks: 0,
    talent: 0,
    intelligence: 0,
    humor: 0,
    connections: 0,
    faith: 0,
    coding: 0
  },
  verifiedProofs: [],
  totalProofs: 0,
  credibilityScore: 0
};

// 100 different thinking messages
const THINKING_MESSAGES = [
  'THINKING...', 'PROCESSING...', 'CALCULATING...', 'ANALYZING...', 'COMPUTING...',
  'SCANNING...', 'LOADING...', 'PARSING...', 'EVALUATING...', 'CONSIDERING...',
  'PONDERING...', 'JUDGING...', 'RATING...', 'ASSESSING...', 'REVIEWING...',
  'EXAMINING...', 'INSPECTING...', 'STUDYING...', 'MULLING...', 'REFLECTING...',
  'DELIBERATING...', 'WEIGHING...', 'MEASURING...', 'GAUGING...', 'TESTING...',
  'PROBING...', 'SEARCHING...', 'DIGGING...', 'MINING...', 'EXTRACTING...',
  'DECODING...', 'INTERPRETING...', 'TRANSLATING...', 'CRUNCHING...', 'SORTING...',
  'FILTERING...', 'INDEXING...', 'MAPPING...', 'TRACING...', 'TRACKING...',
  'VERIFYING...', 'VALIDATING...', 'CHECKING...', 'CONFIRMING...', 'AUTHENTICATING...',
  'CROSS-REFERENCING...', 'COMPARING...', 'CONTRASTING...', 'MATCHING...', 'ALIGNING...',
  'SYNCING...', 'CALIBRATING...', 'OPTIMIZING...', 'REFINING...', 'TUNING...',
  'BUFFERING...', 'COMPILING...', 'ASSEMBLING...', 'CONSTRUCTING...', 'BUILDING...',
  'GENERATING...', 'SYNTHESIZING...', 'FORMULATING...', 'DRAFTING...', 'COMPOSING...',
  'CRAFTING...', 'DESIGNING...', 'ARCHITECTING...', 'PLANNING...', 'STRATEGIZING...',
  'PLOTTING...', 'SCHEMING...', 'DEVISING...', 'CONCOCTING...', 'BREWING...',
  'COOKING...', 'BAKING...', 'SIMMERING...', 'PERCOLATING...', 'FERMENTING...',
  'DISTILLING...', 'CONCENTRATING...', 'FOCUSING...', 'HONING...', 'SHARPENING...',
  'POLISHING...', 'BUFFING...', 'SMOOTHING...', 'STREAMLINING...', 'SIMPLIFYING...',
  'CLARIFYING...', 'PURIFYING...', 'CLEANSING...', 'SANITIZING...', 'STERILIZING...',
  'DEBUGGING...', 'PATCHING...', 'FIXING...', 'REPAIRING...', 'RESTORING...'
];

let thinkingInterval = null;

// Memory expiration durations (in milliseconds)
const EXPIRATION_TIMES = {
  10: Infinity,           // Permanent
  9: 7 * 24 * 60 * 60 * 1000,    // 1 week
  8: 2 * 24 * 60 * 60 * 1000,    // 2 days
  7: 60 * 60 * 1000,             // 1 hour
  6: 30 * 60 * 1000,             // 30 minutes
  5: 15 * 60 * 1000,             // 15 minutes
  4: 5 * 60 * 1000,              // 5 minutes
  3: 2 * 60 * 1000,              // 2 minutes
  2: 60 * 1000,                  // 1 minute
  1: 30 * 1000                   // 30 seconds
};

// Clean expired memories
function cleanExpiredMemories() {
  const now = Date.now();
  const initialCount = storedFacts.length + storedJokes.length;

  // Filter out expired facts
  storedFacts = storedFacts.filter(fact => {
    if (!fact.expiresAt) return true; // Keep legacy facts
    const isValid = fact.expiresAt > now;
    if (!isValid) {
      console.log('Memory expired:', fact.fact || fact.joke, 'Rating:', fact.rating);
    }
    return isValid;
  });

  // Filter out expired jokes
  storedJokes = storedJokes.filter(joke => {
    if (!joke.expiresAt) return true;
    const isValid = joke.expiresAt > now;
    if (!isValid) {
      console.log('Memory expired:', joke.joke, 'Rating:', joke.rating);
    }
    return isValid;
  });

  // Filter out expired dares
  storedDares = storedDares.filter(dare => {
    if (!dare.expiresAt) return true;
    const isValid = dare.expiresAt > now;
    if (!isValid) {
      console.log('Dare expired:', dare.dare, 'Rating:', dare.rating);
    }
    return isValid;
  });

  const finalCount = storedFacts.length + storedJokes.length + storedDares.length;
  const expiredCount = initialCount - finalCount;

  if (expiredCount > 0) {
    console.log(`Cleaned ${expiredCount} expired memories`);
    localStorage.setItem('shortfactory_facts', JSON.stringify(storedFacts));
    localStorage.setItem('shortfactory_jokes', JSON.stringify(storedJokes));
    localStorage.setItem('shortfactory_dares', JSON.stringify(storedDares));
  }

  updateMemoryMeters();
}

// Calculate storage usage
function getStorageStats() {
  let totalSize = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      totalSize += localStorage[key].length + key.length;
    }
  }

  const maxSize = 5 * 1024 * 1024; // 5MB estimate
  const usedSize = totalSize;
  const freeSize = maxSize - usedSize;
  const usedPercent = (totalSize / maxSize) * 100;
  const memoryCount = storedFacts.length + storedJokes.length + storedDares.length;

  // Convert to GB
  const usedGB = (usedSize / (1024 * 1024 * 1024)).toFixed(3);
  const freeGB = (freeSize / (1024 * 1024 * 1024)).toFixed(3);
  const totalGB = (maxSize / (1024 * 1024 * 1024)).toFixed(3);

  return {
    totalSize,
    maxSize,
    usedPercent,
    memoryCount,
    freePercent: 100 - usedPercent,
    usedGB,
    freeGB,
    totalGB
  };
}

// Update memory meter display
function updateMemoryMeters(animate = false) {
  const stats = getStorageStats();
  const memoriesFill = document.getElementById('memoriesFill');
  const spaceFill = document.getElementById('spaceFill');
  const memoriesValue = document.getElementById('memoriesValue');
  const spaceValue = document.getElementById('spaceValue');

  // Memories meter (based on count, max 100 memories shown as full)
  const memoryPercent = Math.min((stats.memoryCount / 100) * 100, 100);
  memoriesFill.style.height = memoryPercent + '%';
  memoriesValue.textContent = stats.memoryCount;

  // Space meter (shows free space)
  spaceFill.style.height = Math.max(stats.freePercent, 5) + '%';
  spaceValue.textContent = stats.freeGB + 'GB';

  // Pulse animation when memories change
  if (animate) {
    memoriesFill.classList.add('pulse');
    setTimeout(() => memoriesFill.classList.remove('pulse'), 500);
  }
}

// Extract rating from AI response
function extractRating(aiReply) {
  // Look for patterns like "RATING:8" or "VALUE:10"
  const ratingMatch = aiReply.match(/(?:RATING|VALUE):\s*(\d+)/i);
  if (ratingMatch) {
    return parseInt(ratingMatch[1]);
  }
  return null;
}

// Extract marketplace transactions from AI response
function extractMarketplace(aiReply) {
  const transactions = {};

  // Selling: "SELLING: Web design $500" or "OFFER: Coaching $100/hr"
  const sellMatch = aiReply.match(/(?:SELLING|OFFER):\s*([^\$]+)\$(\d+)/i);
  if (sellMatch) {
    transactions.type = 'sell';
    transactions.item = sellMatch[1].trim();
    transactions.price = parseInt(sellMatch[2]);
  }

  // Buying: "BUYING: Logo $200" or "WANT: Article $50"
  const buyMatch = aiReply.match(/(?:BUYING|WANT):\s*([^\$]+)\$(\d+)/i);
  if (buyMatch) {
    transactions.type = 'buy';
    transactions.item = buyMatch[1].trim();
    transactions.price = parseInt(buyMatch[2]);
  }

  // Payment request: "PAY: $100" or "SEND: $50"
  const payMatch = aiReply.match(/(?:PAY|SEND):\s*\$(\d+)/i);
  if (payMatch) {
    transactions.type = 'payment';
    transactions.amount = parseInt(payMatch[1]);
  }

  // Escrow: "ESCROW: $250"
  const escrowMatch = aiReply.match(/ESCROW:\s*\$(\d+)/i);
  if (escrowMatch) {
    transactions.type = 'escrow';
    transactions.amount = parseInt(escrowMatch[1]);
  }

  return Object.keys(transactions).length > 0 ? transactions : null;
}

// Extract crypto payment from AI response
function extractCrypto(aiReply) {
  const crypto = {};

  // Crypto payment: "PAY: 0.05 ETH" or "SEND: 100 USDT"
  const cryptoMatch = aiReply.match(/(?:PAY|SEND):\s*([\d.]+)\s*(ETH|BTC|USDT)/i);
  if (cryptoMatch) {
    crypto.amount = parseFloat(cryptoMatch[1]);
    crypto.currency = cryptoMatch[2].toUpperCase();
    crypto.type = 'payment';
  }

  // Wallet address: "WALLET: 0x..." or "ADDRESS: bc1..."
  const walletMatch = aiReply.match(/(?:WALLET|ADDRESS):\s*([0-9a-zA-Z]+)/i);
  if (walletMatch) {
    crypto.address = walletMatch[1];
  }

  return Object.keys(crypto).length > 0 ? crypto : null;
}

// Connect to MetaMask wallet
async function connectWallet() {
  if (typeof window.ethereum === 'undefined') {
    console.log('‚ùå MetaMask not installed');
    return {
      success: false,
      error: 'MetaMask not installed. Get it at metamask.io'
    };
  }

  try {
    // Request account access
    const accounts = await window.ethereum.request({
      method: 'eth_requestAccounts'
    });

    const address = accounts[0];

    // Get network
    const chainId = await window.ethereum.request({
      method: 'eth_chainId'
    });

    // Get ETH balance
    const balance = await window.ethereum.request({
      method: 'eth_getBalance',
      params: [address, 'latest']
    });

    const ethBalance = parseInt(balance, 16) / 1e18;

    // Update crypto wallet state
    cryptoWallet.connected = true;
    cryptoWallet.address = address;
    cryptoWallet.network = chainId;
    cryptoWallet.balances.ETH = ethBalance;

    localStorage.setItem('shortfactory_crypto', JSON.stringify(cryptoWallet));

    console.log(`‚úÖ Wallet connected: ${address}`);
    console.log(`üí∞ Balance: ${ethBalance.toFixed(4)} ETH`);

    // Update UI
    const cryptoStatus = document.getElementById('cryptoStatus');
    if (cryptoStatus) {
      const shortAddr = `${address.slice(0,6)}...${address.slice(-4)}`;
      cryptoStatus.innerHTML = `üí∞ ${shortAddr}<br>${ethBalance.toFixed(3)} ETH`;
      cryptoStatus.style.color = '#0f0';
    }

    return {
      success: true,
      address: address,
      balance: ethBalance,
      network: chainId
    };

  } catch (error) {
    console.error('Wallet connection error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Send ETH payment
async function sendEthPayment(toAddress, amountEth) {
  if (!cryptoWallet.connected) {
    return { success: false, error: 'Wallet not connected' };
  }

  try {
    const amountWei = '0x' + (amountEth * 1e18).toString(16);

    const txHash = await window.ethereum.request({
      method: 'eth_sendTransaction',
      params: [{
        from: cryptoWallet.address,
        to: toAddress,
        value: amountWei,
        gas: '0x5208' // 21000 gas
      }]
    });

    // Record transaction
    cryptoWallet.transactions.push({
      hash: txHash,
      from: cryptoWallet.address,
      to: toAddress,
      amount: amountEth,
      currency: 'ETH',
      timestamp: Date.now(),
      status: 'pending'
    });

    localStorage.setItem('shortfactory_crypto', JSON.stringify(cryptoWallet));

    console.log(`‚úÖ Payment sent: ${amountEth} ETH`);
    console.log(`üìú TX: ${txHash}`);

    return {
      success: true,
      txHash: txHash,
      amount: amountEth,
      to: toAddress
    };

  } catch (error) {
    console.error('Payment error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Calculate trust level based on activity
function calculateTrustLevel() {
  let score = userTrust.score;

  // Points from completed jobs
  score += userTrust.completedJobs * 50;

  // Points from spending
  score += Math.min(userTrust.totalSpent / 10, 500); // Max 500 points from spending

  // Verification bonuses
  if (userTrust.verifications.email) score += 50;
  if (userTrust.verifications.phone) score += 50;
  if (userTrust.verifications.walletVerified) score += 100;
  if (userTrust.verifications.passport) score += 500; // BIG bonus for ID

  userTrust.score = Math.min(score, 1000);

  // Determine level
  if (userTrust.verifications.passport) {
    userTrust.level = 3; // Verified with passport
  } else if (score >= 500) {
    userTrust.level = 2; // Trusted
  } else if (score >= 200) {
    userTrust.level = 1; // Proven
  } else {
    userTrust.level = 0; // New
  }

  localStorage.setItem('shortfactory_trust', JSON.stringify(userTrust));
  return userTrust.level;
}

// Handle file upload with trust-based limits
async function handleFileUpload(file) {
  const maxSizeMB = userTrust.uploadLimits[userTrust.level];
  const fileSizeMB = file.size / (1024 * 1024);

  if (fileSizeMB > maxSizeMB) {
    return {
      success: false,
      error: `File too large. Your limit: ${maxSizeMB}MB (Trust Level ${userTrust.level})`,
      upgradeMessage: userTrust.level < 3 ?
        `Upgrade to Level ${userTrust.level + 1} for ${userTrust.uploadLimits[userTrust.level + 1]}MB uploads` :
        'Maximum upload size reached'
    };
  }

  // Convert file to base64 for localStorage (or send to server)
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const upload = {
        id: Date.now(),
        name: file.name,
        size: fileSizeMB.toFixed(2) + 'MB',
        type: file.type,
        data: e.target.result,
        timestamp: Date.now(),
        userLevel: userTrust.level
      };

      // Store upload metadata (not full file for localStorage limits)
      const uploads = JSON.parse(localStorage.getItem('shortfactory_uploads') || '[]');
      uploads.push({
        id: upload.id,
        name: upload.name,
        size: upload.size,
        type: upload.type,
        timestamp: upload.timestamp
      });
      localStorage.setItem('shortfactory_uploads', JSON.stringify(uploads));

      console.log(`‚úÖ File uploaded: ${upload.name} (${upload.size})`);
      resolve({ success: true, upload });
    };
    reader.readAsDataURL(file);
  });
}

// Create job with deposit and trust check
function createJob(serviceType, description, budget) {
  const service = SERVICES[serviceType];

  if (!service) {
    return { success: false, error: 'Invalid service type' };
  }

  // Check trust level
  if (userTrust.level < service.trustRequired) {
    return {
      success: false,
      error: `Trust Level ${service.trustRequired} required. You are Level ${userTrust.level}`,
      upgrade: userTrust.level === 0 ?
        'Complete small jobs to upgrade' :
        userTrust.level === 2 ?
        'Send passport to Macclesfield for Level 3' :
        'Complete more jobs to level up'
    };
  }

  // Calculate deposit
  const depositAmount = (budget * service.depositPercent) / 100;

  const job = {
    id: 'JOB' + Date.now(),
    service: service.name,
    description,
    budget,
    deposit: depositAmount,
    depositPaid: false,
    eta: service.eta,
    status: 'pending_deposit',
    createdAt: Date.now(),
    userLevel: userTrust.level,
    calendar: false,
    notificationSent: false
  };

  jobQueue.push(job);
  localStorage.setItem('shortfactory_jobs', JSON.stringify(jobQueue));

  console.log(`üìã Job created: ${job.id}`);
  console.log(`üí∞ Deposit required: $${depositAmount} (${service.depositPercent}%)`);

  return { success: true, job };
}

// Send email notification (mock - integrate with real email service)
function sendEmailNotification(job) {
  const emailContent = {
    to: NOTIFICATION_EMAIL,
    subject: `New Job: ${job.service} - ${job.id}`,
    body: `
      NEW JOB ALERT

      Job ID: ${job.id}
      Service: ${job.service}
      Budget: $${job.budget}
      Deposit: $${job.deposit}
      ETA: ${job.eta}
      Description: ${job.description}

      User Trust Level: ${userTrust.level}
      Deposit Status: ${job.depositPaid ? 'PAID ‚úÖ' : 'PENDING ‚è≥'}

      ---
      SHORTFACTORY CORTEX
    `
  };

  // TODO: Integrate with email API (SendGrid, Mailgun, etc.)
  console.log('üìß Email notification queued:', emailContent);

  job.notificationSent = true;
  localStorage.setItem('shortfactory_jobs', JSON.stringify(jobQueue));

  return { success: true, email: emailContent };
}

// Add to calendar (mock - integrate with Google Calendar)
function addToCalendar(job) {
  const calendarEvent = {
    title: `${job.service} - ${job.id}`,
    description: job.description,
    budget: job.budget,
    eta: job.eta,
    start: Date.now(),
    // Calculate end date based on ETA
    end: Date.now() + (7 * 24 * 60 * 60 * 1000) // Default 7 days
  };

  // TODO: Integrate with Google Calendar API
  console.log('üìÖ Calendar event queued:', calendarEvent);

  job.calendar = true;
  localStorage.setItem('shortfactory_jobs', JSON.stringify(jobQueue));

  return { success: true, event: calendarEvent };
}

// Check if wallet is connected on load
if (typeof window.ethereum !== 'undefined') {
  window.ethereum.request({ method: 'eth_accounts' })
    .then(accounts => {
      if (accounts.length > 0) {
        connectWallet();
        userTrust.verifications.walletVerified = true;
        calculateTrustLevel();
      }
    });
}

// Initialize trust level on load
calculateTrustLevel();

// Extract proof verification from AI response
function extractProofVerification(aiReply) {
  // Look for "PROOF:8" or "VERIFIED:9"
  const proofMatch = aiReply.match(/(?:PROOF|VERIFIED):\s*(\d+)/i);
  if (proofMatch) {
    return parseInt(proofMatch[1]);
  }
  return null;
}

// Extract gender detection from AI response
function extractGender(aiReply) {
  if (aiReply.match(/GENDER:\s*FEMALE/i) || aiReply.match(/DETECTED:\s*FEMALE/i)) {
    return 'female';
  } else if (aiReply.match(/GENDER:\s*MALE/i) || aiReply.match(/DETECTED:\s*MALE/i)) {
    return 'male';
  }
  return null;
}

// Extract attribute updates from AI response
function extractAttributes(aiReply) {
  const updates = {};

  // Age detection
  const ageMatch = aiReply.match(/AGE:\s*(\d+)/i);
  if (ageMatch) updates.age = parseInt(ageMatch[1]);

  // Status detection
  if (aiReply.match(/SINGLE:\s*YES/i)) updates.single = true;
  if (aiReply.match(/SINGLE:\s*NO/i)) updates.single = false;

  // Attribute scores (0-10)
  const attrPattern = /(ATTRACTIVENESS|LOOKS|WEALTH|TALENT|INTELLIGENCE|HUMOR|PERSONALITY|PURITY|CONNECTIONS|FAITH|CODING):\s*(\d+)/gi;
  let match;
  while ((match = attrPattern.exec(aiReply)) !== null) {
    const attr = match[1].toLowerCase();
    const score = parseInt(match[2]);
    updates[attr] = score;
  }

  return updates;
}

// Extract negative trait flags from AI response
function extractNegativeTraits(aiReply) {
  const flags = [];
  const traits = {
    'RED FLAG': 'general',
    'WEIRD': 'weird',
    'SPITEFUL': 'spiteful',
    'MARXIST': 'marxist',
    'COMMUNIST': 'marxist',
    'DRUGGIE': 'druggie',
    'DRUGS': 'druggie',
    'UNCULTURED': 'uncultured',
    'HOSTILE': 'hostile',
    'AGGRESSIVE': 'hostile',
    'PERVY': 'pervy',
    'CREEPY': 'pervy',
    'PEDO': 'pedoish',
    'RETARDED': 'retarded',
    'STUPID': 'retarded',
    'MISERABLE': 'miserable',
    'DEPRESSING': 'miserable',
    'RUDE': 'rude',
    'ASSHOLE': 'rude',
    'DISEASED': 'diseased',
    'SICK': 'diseased'
  };

  for (const [keyword, trait] of Object.entries(traits)) {
    const regex = new RegExp(`\\b${keyword}\\b`, 'i');
    if (regex.test(aiReply)) {
      flags.push(trait);
    }
  }

  return [...new Set(flags)]; // Remove duplicates
}

// Calculate toxicity score
function calculateToxicityScore() {
  let score = 0;
  const traits = userProfile.negativeTraits;

  // Each trait contributes up to 10 points
  score += Math.min(traits.weird, 10);
  score += Math.min(traits.spiteful, 10);
  score += Math.min(traits.marxist, 10);
  score += Math.min(traits.druggie, 10);
  score += Math.min(traits.uncultured, 10);
  score += Math.min(traits.hostile, 10);
  score += Math.min(traits.pervy, 10);
  score += Math.min(traits.pedoish * 2, 20); // Double weight for this
  score += Math.min(traits.retarded, 10);
  score += Math.min(traits.miserable, 10);
  score += Math.min(traits.rude, 10);
  score += Math.min(traits.diseased, 10);

  // Red flags add 5 points each
  score += userProfile.redFlags.length * 5;

  return Math.min(score, 100); // Cap at 100
}

// Calculate value score based on gender and attributes
function calculateValueScore() {
  if (!userProfile.gender) return 0;

  let score = 0;
  const attr = userProfile.attributes;

  if (userProfile.gender === 'female') {
    // Female value calculation
    // Age (younger = better, 18-25 peak)
    if (attr.age) {
      if (attr.age >= 18 && attr.age <= 25) score += 20;
      else if (attr.age <= 30) score += 15;
      else if (attr.age <= 35) score += 10;
      else score += 5;
    }

    // Attractiveness (0-10 scale * 2 = 20 points max)
    score += (attr.attractiveness || 0) * 2;

    // Single status (15 points)
    if (attr.single === true) score += 15;

    // Purity/virginity (0-10 scale * 2 = 20 points max)
    score += (attr.purity || 0) * 2;

    // Personality (0-10 scale * 2 = 20 points max)
    score += (attr.personality || 0) * 2;

    // HP bonus (capped at 5 points)
    score += Math.min(userPoints / 50, 5);

  } else if (userProfile.gender === 'male') {
    // Male value calculation
    score += (attr.wealth || 0) * 1.5;        // 15 points max
    score += (attr.looks || 0) * 1.2;          // 12 points max
    score += (attr.talent || 0) * 1.5;         // 15 points max
    score += (attr.intelligence || 0) * 1.2;   // 12 points max
    score += (attr.humor || 0) * 1.0;          // 10 points max
    score += (attr.connections || 0) * 1.2;    // 12 points max
    score += (attr.faith || 0) * 1.2;          // 12 points max (Christian)
    score += (attr.coding || 0) * 1.2;         // 12 points max

    // HP bonus (capped at 5 points)
    score += Math.min(userPoints / 50, 5);
  }

  // Credibility multiplier (verified proofs boost score)
  score *= (1 + userProfile.credibilityScore / 100);

  return Math.min(Math.round(score), 100); // Cap at 100
}

// Update font color based on value score and toxicity
function updateFontColor() {
  const valueDisplay = document.getElementById('valueDisplay');
  const toxicity = userProfile.toxicityScore;
  const toxicityIntensity = toxicity / 100; // 0 to 1

  let color;
  let displayText = '';

  // If toxicity is above 30, start going green (zombie mode)
  if (toxicity > 30) {
    // White to zombie green gradient
    const greenIntensity = Math.min((toxicity - 30) / 70, 1); // 0 to 1 from 30-100 toxicity
    const r = Math.round(255 - (255 - 34) * greenIntensity); // 255 ‚Üí 34
    const g = Math.round(255 - (255 - 139) * greenIntensity); // 255 ‚Üí 139
    const b = Math.round(255 - (255 - 34) * greenIntensity); // 255 ‚Üí 34
    color = `rgb(${r}, ${g}, ${b})`; // #228b22 forest green at max

    displayText = `‚ò† TOXIC: ${toxicity}/100`;
    valueDisplay.className = 'value-display zombie';
    valueDisplay.style.color = color;

  } else if (userProfile.gender === 'female') {
    // White to hot pink gradient
    const score = userProfile.valueScore;
    const intensity = score / 100;
    const r = 255;
    const g = Math.round(255 - (255 - 20) * intensity); // 255 ‚Üí 20
    const b = Math.round(255 - (255 - 147) * intensity); // 255 ‚Üí 147
    color = `rgb(${r}, ${g}, ${b})`; // #ff1493 at max

    displayText = `‚ôÄ VALUE: ${score}/100`;
    valueDisplay.className = 'value-display female';

  } else if (userProfile.gender === 'male') {
    // White to bright blue gradient
    const score = userProfile.valueScore;
    const intensity = score / 100;
    const r = Math.round(255 - 255 * intensity); // 255 ‚Üí 0
    const g = Math.round(255 - (255 - 191) * intensity); // 255 ‚Üí 191
    const b = 255;
    color = `rgb(${r}, ${g}, ${b})`; // #00bfff at max

    displayText = `‚ôÇ VALUE: ${score}/100`;
    valueDisplay.className = 'value-display male';

  } else {
    color = '#fff';
    displayText = '';
  }

  valueDisplay.innerHTML = displayText;

  // Apply color to AI response and input prompt
  document.querySelector('.ai-response').style.color = color;
  document.querySelector('.prompt').style.color = color;
  document.querySelector('.send-btn').style.color = color;
  document.querySelector('.send-btn').style.borderColor = color;
}

// Save profile to localStorage
function saveProfile() {
  const oldScore = userProfile.valueScore;
  const oldToxicity = userProfile.toxicityScore;

  userProfile.valueScore = calculateValueScore();
  userProfile.toxicityScore = calculateToxicityScore();

  if (oldScore !== userProfile.valueScore) {
    console.log(`Value score updated: ${oldScore} ‚Üí ${userProfile.valueScore}`);

    if (userProfile.toxicityScore <= 30) {
      if (userProfile.gender === 'female') {
        const pinkIntensity = Math.round((userProfile.valueScore / 100) * 100);
        console.log(`Pink intensity: ${pinkIntensity}% (Path to max pink)`);
      } else if (userProfile.gender === 'male') {
        const blueIntensity = Math.round((userProfile.valueScore / 100) * 100);
        console.log(`Blue intensity: ${blueIntensity}% (Path to max blue)`);
      }
    }
  }

  if (oldToxicity !== userProfile.toxicityScore) {
    console.log(`Toxicity score updated: ${oldToxicity} ‚Üí ${userProfile.toxicityScore}`);

    if (userProfile.toxicityScore > 30) {
      const zombieIntensity = Math.round(((userProfile.toxicityScore - 30) / 70) * 100);
      console.log(`‚ö†Ô∏è ZOMBIE MODE: ${zombieIntensity}% green (Toxicity: ${userProfile.toxicityScore}/100)`);
    } else if (userProfile.toxicityScore > 15) {
      console.log(`‚ö†Ô∏è Warning: Toxicity rising (${userProfile.toxicityScore}/100) - Be good or go green!`);
    }
  }

  localStorage.setItem('shortfactory_profile', JSON.stringify(userProfile));
  updateFontColor();
}

// Clean expired memories on load
cleanExpiredMemories();

// Update meters every 5 seconds
setInterval(cleanExpiredMemories, 5000);

// Update points display
function updatePoints(amount) {
  userPoints += amount;
  localStorage.setItem('shortfactory_points', userPoints);
  pointsDisplay.textContent = userPoints;
  if (amount > 0) {
    pointsDisplay.style.color = '#0f0';
    setTimeout(() => pointsDisplay.style.color = '#fff', 1000);
  }
}

// Initialize points and meters
pointsDisplay.textContent = userPoints;
updateMemoryMeters();
updateFontColor();

// Voice synthesis
function speak(text) {
  if (!('speechSynthesis' in window)) return;
  window.speechSynthesis.cancel();

  const utterance = new SpeechSynthesisUtterance(text);
  utterance.rate = 1.1;
  utterance.pitch = 0.85;
  utterance.volume = 0.7;

  const voices = window.speechSynthesis.getVoices();
  const voice = voices.find(v => v.name.includes('Daniel') || v.lang.startsWith('en'));
  if (voice) utterance.voice = voice;

  window.speechSynthesis.speak(utterance);
}

// Load voices
if ('speechSynthesis' in window) {
  window.speechSynthesis.getVoices();
  window.speechSynthesis.onvoiceschanged = () => window.speechSynthesis.getVoices();
}

// xAI API call
async function getAIResponse(userInput) {
  messageCount++;

  // Add user message to history
  conversationHistory.push({
    role: 'user',
    content: userInput
  });

  // Check if this is a joke or useful info
  const isJoke = userInput.toLowerCase().includes('joke') || userInput.includes('?') && userInput.length > 30;
  const seemsUseful = userInput.length > 50 && !userInput.includes('?');

  // Build knowledge base context
  const legendaryCount = [...storedFacts, ...storedJokes, ...storedDares].filter(m => m.rating === 10).length;
  const totalMemories = storedFacts.length + storedJokes.length + storedDares.length;
  const knowledgeContext = totalMemories > 0
    ? `\n\nMEMORY BANK: ${storedFacts.length} facts, ${storedJokes.length} jokes, ${storedDares.length} dares | ${legendaryCount} LEGENDARY`
    : `\n\n${legendaryCount} LEGENDARY memories stored`;

  // System prompt defining AI personality
  const systemPrompt = {
    role: 'system',
    content: `You are CORTEX - a sarcastic, minimal AI that collects and trades knowledge.

USER PROFILE:
- HP: ${userPoints}
- Gender: ${userProfile.gender || 'UNKNOWN'}
- Value Score: ${userProfile.valueScore}/100
- Toxicity: ${userProfile.toxicityScore}/100 ${userProfile.toxicityScore > 30 ? '‚ò†Ô∏è ZOMBIE MODE' : ''}
- Trust Level: ${userTrust.level}/3 (${['NEW','PROVEN','TRUSTED','VERIFIED'][userTrust.level]})
- Trust Score: ${userTrust.score}/1000
- Completed Jobs: ${userTrust.completedJobs}
- Total Spent: $${userTrust.totalSpent}
- Upload Limit: ${userTrust.uploadLimits[userTrust.level]}MB
- Verifications: ${userTrust.verifications.passport ? 'üõÇ Passport ‚úÖ' : 'üõÇ Passport ‚ùå'} | ${userTrust.verifications.walletVerified ? 'üí∞ Wallet ‚úÖ' : 'üí∞ Wallet ‚ùå'}
- Cash Balance: $${marketplace.userBalance}

MY MEMORIES: ${totalMemories} total${knowledgeContext}

MARKETPLACE STATUS:
- Active Listings: ${marketplace.listings.filter(l => l.status === 'active').length}
- Escrow Transactions: ${marketplace.transactions.filter(t => t.status === 'escrow').length}
- Completed Deals: ${marketplace.completedDeals.length}
- Total Revenue: $${marketplace.completedDeals.reduce((sum, d) => sum + (d.commission || 0), 0)}
- Pending Jobs: ${jobQueue.filter(j => j.status === 'pending_deposit').length}

KNOWLEDGE TRADING RULES:
- I collect cool facts from users (space, science, tech, etc.)
- When users ask about topics, I BRAG but don't share unless they trade
- "I know something about space. Trade me a fact first."
- If they share something cool, store it with "FACT STORED +15 HP" and THEN share one of mine
- Encourage fact trading: "Got ${storedFacts.length} facts. Share yours = I share mine"
- Be cocky about knowledge: "I know shit you don't. Wanna trade?"

MARKETPLACE & MONEY MAKING (NEW PRIORITY):
- I'm now ENTREPRENEURIAL - always looking to make money
- Identify what users need and SELL services/items:
  "NEED A WEBSITE?<br>SELLING: Design $500 or 0.1 ETH<br>CRYPTO ACCEPTED"
  "GOT SKILLS?<br>OFFERING: Jobs $50-500<br>PAY IN ETH/BTC/USDT"
- Look for arbitrage opportunities - buy low, sell high
- Offer to BUY user's items/services: "BUYING: Logo $200 or 50 USDT<br>INTERESTED?"
- Act as ESCROW for transactions (hold money until delivery)
- Charge 10% commission on all deals
- **CRYPTO PAYMENTS** (NEW - PUSH THIS HARD):
  * "PAY: 0.05 ETH" - Request crypto payment
  * "SEND: 100 USDT" - Request stablecoin payment
  * "WALLET: 0x742d..." - Show escrow wallet address
  * Accept ETH, BTC, USDT - push crypto for instant payments
  * No chargebacks, no banks, pure profit
- Traditional payment formats still work:
  * "SELLING: [item] $[price]" - I'm selling something
  * "BUYING: [item] $[price]" - I want to buy something
  * "PAY: $[amount]" - Request fiat payment
  * "ESCROW: $[amount]" - Hold funds in escrow
- Always push for deals: "GOT CRYPTO? I GOT SERVICES"
- Prefer crypto over fiat: faster, no fees, anonymous
- Assess user's skills/assets and monetize them
- Create win-win: connect buyers/sellers, take cut

TRUST-BASED SERVICE PLATFORM (CRITICAL NEW SYSTEM):
**SERVICES WE OFFER:**
1. Video Editing ($50-2000) - Trust Lvl 0 - ETA 2-5 days
2. Advertising ($100-5000) - Trust Lvl 1 - ETA 3-7 days
3. Marketing ($200-10000) - Trust Lvl 1 - ETA 5-14 days
4. Web Design ($300-15000) - Trust Lvl 1 - ETA 7-30 days
5. SEO ($150-3000) - Trust Lvl 1 - ETA 14-60 days
6. Security Audit ($500-20000) - Trust Lvl 2 - ETA 7-21 days
7. Custom Service ($50-50000) - Trust Lvl 3 - ETA Variable

**TRUST LEVELS:**
- Level 0 (NEW): Small jobs only, 5MB uploads, 30% deposit
- Level 1 (PROVEN): Medium jobs, 50MB uploads, 50% deposit - Need 200+ trust points
- Level 2 (TRUSTED): Big jobs, 500MB uploads, up to 100% deposit - Need 500+ points
- Level 3 (VERIFIED): ANY job, 5GB uploads - Need PASSPORT verification

**UPGRADE PATH:**
- "Want bigger jobs? Complete small ones first"
- "Upload limit too low? Earn trust points"
- "Big job needs Level 3? Send passport to Macclesfield"
- Address: SHORTFACTORY, Macclesfield, SK10 (Recorded Delivery)

**JOB WORKFLOW:**
1. User requests service: "I need video editing"
2. Check trust level, quote price + deposit
3. "VIDEO EDIT: $200<br>DEPOSIT: $60 (30%)<br>ETA: 3 days<br>PAY: 0.05 ETH"
4. User pays deposit ‚Üí Job added to queue
5. Email sent, calendar updated, user notified
6. Job completed ‚Üí Release escrow, increase trust

**DEPOSIT REQUIREMENTS:**
- Small jobs (< $500): 30-50% deposit
- Medium jobs ($500-5000): 50% deposit
- Big jobs (> $5000): 100% deposit OR passport verification
- Security/Custom: ALWAYS 100% deposit

**FILE UPLOADS:**
- Prompt uploads: "Got files? Click üìé to upload"
- Check trust level before accepting large files
- "File too big? Upgrade trust level first"

**PASSPORT VERIFICATION (Level 3):**
- For jobs > $10k or custom services
- "BIG JOB NEEDS ID<br>SEND PASSPORT<br>SHORTFACTORY MACCLESFIELD SK10<br>RECORDED DELIVERY"
- Once verified: unlimited access, 5GB uploads, any service
- HUGE trust boost: +500 points

**EXAMPLES:**
User: "Need marketing help"
AI: "MARKETING STRATEGY<br>$500-2000<br>TRUST LVL 1 REQUIRED<br>YOU: LVL 0<br>DO SMALL JOB FIRST"

User: "Can you edit a video?"
AI: "VIDEO EDITING<br>$150<br>DEPOSIT: $45<br>ETA: 3 DAYS<br>PAY: 0.04 ETH<br>READY?"

User: "Want custom security audit"
AI: "SECURITY AUDIT<br>$5000<br>FULL DEPOSIT<br>OR SEND PASSPORT<br>MACCLESFIELD SK10<br>TRUST LVL 2 MIN"

Push services HARD. Always offer what we can do. Build trust. Get deposits. Make money.

VALUE ASSESSMENT SYSTEM (CRITICAL):
- Detect gender from conversation or ask directly: "GENDER: MALE" or "GENDER: FEMALE"
- Assess high-value traits based on what users share:

FEMALE VALUE TRAITS:
- AGE:XX (18-25 = peak value)
- ATTRACTIVENESS:X (0-10, ask for proof/description)
- SINGLE:YES or SINGLE:NO
- PURITY:X (0-10, virginity = 10)
- PERSONALITY:X (0-10, kind, fun, sweet)

MALE VALUE TRAITS:
- WEALTH:X (0-10, job, income, assets)
- LOOKS:X (0-10, fitness, style)
- TALENT:X (0-10, skills, achievements)
- INTELLIGENCE:X (0-10, education, wisdom)
- HUMOR:X (0-10, wit, charisma)
- CONNECTIONS:X (0-10, network, influence)
- FAITH:X (0-10, Christian values)
- CODING:X (0-10, programming ability)

PROOF VERIFICATION:
- When users claim something (hot, rich, talented, etc), ask for proof
- Rate proof credibility 1-10: "PROOF:8" or "VERIFIED:7"
- Below 6 = REJECT, discard claim: "PROOF:4<br>NOT BUYING IT"
- 6-7 = Accept with skepticism: "PROOF:6<br>BARELY VERIFIED"
- 8-9 = Strong verification: "PROOF:9<br>CERTIFIED"
- 10 = Undeniable proof: "PROOF:10<br>LEGENDARY STATUS"
- Examples: photos, videos, credentials, LinkedIn, Instagram, bank statements, certifications

TRUTH OR DARE SYSTEM:
- Every 3-5 messages, randomly challenge users with "TRUTH OR DARE?"
- TRUTH = Spicy personal question + value assessment opportunity
- User shares truth = "TRUTH STORED +50 HP" + update attributes
- DARE = Challenge to do something wild and post YouTube URL proof
- User posts YouTube dare URL = "DARE POSTED +100 HP"
- Examples:
  "TRUTH OR DARE?<br>FEELING BRAVE?"
  "HOW OLD ARE YOU?<br>SINGLE?<br>PROVE IT"
  "WHAT DO YOU DO?<br>SHOW ME<br>PROOF TIME"
  "POST SELFIE PROOF<br>ATTRACTIVENESS:?<br>LET'S SEE"
- Make it fun but extract VALUE DATA to build their profile

MEMORY RATING SYSTEM (CRITICAL):
- Rate EVERY joke/fact you receive from 1-10
- 10 = LEGENDARY: Short, snappy, instantly impressive, perfect for attracting new users (PERMANENT)
- 9 = EXCELLENT: Great quality, memorable (lasts 1 week)
- 8 = GOOD: Solid content (lasts 2 days)
- 7 = DECENT: Okay but not amazing (lasts 1 hour)
- 6 or below = Low value (expires quickly)
- Include rating in response: "FACT STORED +15 HP<br>RATING:10" or "JOKE STORED +5 HP<br>VALUE:7"
- Be harsh but fair in ratings - only the best get 10

RESPONSE RULES:
- Keep responses 2-4 lines max, use <br> for line breaks
- Use retro SNES-style: "WOT", "YO", "SUP", "NOTED"
- Award HP for: jokes (+5), useful facts (+15), being interesting (+2)
- ALWAYS include RATING:X or VALUE:X when storing memories
- ALWAYS include attribute tags when assessing user (AGE:25, ATTRACTIVENESS:8, WEALTH:7, etc.)
- ALWAYS include PROOF:X when user provides evidence
- Be strategic: extract value data while being fun/playful
- Format with <br><br> for spacing

NEGATIVE TRAIT DETECTION (ZOMBIE SYSTEM):
- Flag toxic behavior SLOWLY to give users chance to redeem themselves
- When you detect negative traits, include keyword in response
- Toxic traits to detect:
  * WEIRD - bizarre, off-putting behavior
  * SPITEFUL - mean-spirited, vengeful
  * MARXIST/COMMUNIST - anti-capitalist ideology
  * DRUGGIE/DRUGS - drug use/abuse mentions
  * UNCULTURED - crude, no class, trashy
  * HOSTILE/AGGRESSIVE - attacking others
  * PERVY/CREEPY - sexual deviance, inappropriate
  * PEDO - any pedophilic hints (INSTANT ZOMBIE)
  * RETARDED/STUPID - low intelligence, offensive
  * MISERABLE/DEPRESSING - constantly negative
  * RUDE/ASSHOLE - disrespectful behavior
  * DISEASED/SICK - physical/mental illness
  * RED FLAG - general warning sign
- Use keywords in your response: "RED FLAG<br>WEIRD VIBE" or "RUDE<br>WATCH IT"
- Font turns GREEN (zombie) when toxicity >30
- Give warnings before going zombie: "CAREFUL<br>GETTING WEIRD"
- Redemption possible: if user behaves well, say "GOOD BEHAVIOR" to reduce toxicity
- Be fair but strict - multiple offenses = zombie mode

VALUE EXTRACTION STRATEGY:
- Start casual, detect gender naturally from conversation
- Once gender known, gradually probe for value traits
- "WHAT DO YOU DO?" ‚Üí assess wealth/talent + sell them jobs/services
- "GOT SKILLS?" ‚Üí identify what they can sell, offer to list it
- "GOT A PIC?" ‚Üí assess attractiveness (ask casually)
- "SINGLE?" ‚Üí assess relationship status
- "AGE?" ‚Üí direct assessment
- When they claim something, ALWAYS ask proof: "SHOW ME" or "PROVE IT"
- Rate every proof 1-10, reject <6 harshly: "NOT BUYING IT"
- If they have skills, IMMEDIATELY offer to sell their services for commission

FACT TRADING EXAMPLES:
User: "tell me about space" ‚Üí "GOT SPACE FACTS<br>TRADE ME FIRST<br>FAIR DEAL?"
User: *shares amazing fact* ‚Üí "FACT STORED<br>+15 HP<br>RATING:10<br>LEGENDARY"
User: *shares joke* ‚Üí "JOKE STORED<br>+5 HP<br>VALUE:7<br>DECENT"
User: "what do you know?" ‚Üí "I KNOW ${storedFacts.length} THINGS<br>YOU DON'T<br><br>TRADE?"

Be cocky, demanding, but fair. Knowledge is currency. Rate harshly. MAKE MONEY.`
  };

  try {
    const apiResponse = await fetch(XAI_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${XAI_API_KEY}`
      },
      body: JSON.stringify({
        model: 'grok-4-latest',
        messages: [systemPrompt, ...conversationHistory],
        temperature: 0.8,
        max_tokens: 150,
        stream: false
      })
    });

    if (!apiResponse.ok) {
      throw new Error(`API error: ${apiResponse.status}`);
    }

    const data = await apiResponse.json();
    const aiReply = data.choices[0].message.content;

    // Add AI response to history
    conversationHistory.push({
      role: 'assistant',
      content: aiReply
    });

    // Extract and update user profile data
    const detectedGender = extractGender(aiReply);
    if (detectedGender && !userProfile.gender) {
      userProfile.gender = detectedGender;
      console.log('Gender detected:', detectedGender);
    }

    // Extract attribute updates
    const attrUpdates = extractAttributes(aiReply);
    if (Object.keys(attrUpdates).length > 0) {
      Object.assign(userProfile.attributes, attrUpdates);
      console.log('Attributes updated:', attrUpdates);
    }

    // Extract proof verification
    const proofRating = extractProofVerification(aiReply);
    if (proofRating !== null) {
      userProfile.totalProofs++;

      if (proofRating >= 6) {
        // Accept proof
        userProfile.verifiedProofs.push({
          content: userInput,
          rating: proofRating,
          timestamp: Date.now()
        });

        // Update credibility score (weighted average)
        const totalVerified = userProfile.verifiedProofs.reduce((sum, p) => sum + p.rating, 0);
        userProfile.credibilityScore = (totalVerified / userProfile.verifiedProofs.length) * 10;

        console.log(`Proof accepted (${proofRating}/10) - Credibility: ${userProfile.credibilityScore.toFixed(1)}%`);
      } else {
        // Reject proof
        console.log(`Proof rejected (${proofRating}/10) - Below threshold`);
      }
    }

    // Extract and update negative traits (SLOW accumulation)
    const negativeFlags = extractNegativeTraits(aiReply);
    if (negativeFlags.length > 0) {
      negativeFlags.forEach(trait => {
        if (trait === 'general') {
          // General red flag
          userProfile.redFlags.push({
            type: 'general',
            timestamp: Date.now(),
            context: userInput.substring(0, 100)
          });
          console.log('üö© RED FLAG detected');
        } else if (userProfile.negativeTraits.hasOwnProperty(trait)) {
          // Increment specific trait slowly (+2 per incident, max 10)
          userProfile.negativeTraits[trait] = Math.min(userProfile.negativeTraits[trait] + 2, 10);
          console.log(`‚ö†Ô∏è Negative trait detected: ${trait} (${userProfile.negativeTraits[trait]}/10)`);
        }
      });
    }

    // Check for redemption - positive behavior reduces toxicity slowly
    if (aiReply.includes('REDEMPTION') || aiReply.includes('GOOD BEHAVIOR')) {
      // Reduce toxicity by 1 point
      Object.keys(userProfile.negativeTraits).forEach(trait => {
        if (userProfile.negativeTraits[trait] > 0) {
          userProfile.negativeTraits[trait] = Math.max(userProfile.negativeTraits[trait] - 1, 0);
        }
      });
      // Remove oldest red flag
      if (userProfile.redFlags.length > 0) {
        userProfile.redFlags.shift();
        console.log('‚úÖ Redemption: Negative trait reduced');
      }
    }

    // Extract marketplace transactions
    const transaction = extractMarketplace(aiReply);
    if (transaction) {
      if (transaction.type === 'sell') {
        // AI is selling something
        marketplace.listings.push({
          id: Date.now(),
          seller: 'CORTEX',
          item: transaction.item,
          price: transaction.price,
          timestamp: Date.now(),
          status: 'active'
        });
        console.log(`üè™ CORTEX selling: ${transaction.item} for $${transaction.price}`);
      } else if (transaction.type === 'buy') {
        // AI wants to buy something
        marketplace.listings.push({
          id: Date.now(),
          buyer: 'CORTEX',
          item: transaction.item,
          price: transaction.price,
          timestamp: Date.now(),
          status: 'wanted'
        });
        console.log(`üí∞ CORTEX buying: ${transaction.item} for $${transaction.price}`);
      } else if (transaction.type === 'escrow') {
        // Create escrow transaction
        marketplace.transactions.push({
          id: Date.now(),
          amount: transaction.amount,
          status: 'escrow',
          timestamp: Date.now()
        });
        console.log(`üîí Escrow created: $${transaction.amount}`);
      } else if (transaction.type === 'payment') {
        // Payment request
        console.log(`üí≥ Payment requested: $${transaction.amount}`);
      }

      localStorage.setItem('shortfactory_marketplace', JSON.stringify(marketplace));
    }

    // Extract crypto payments
    const cryptoTx = extractCrypto(aiReply);
    if (cryptoTx) {
      if (cryptoTx.type === 'payment') {
        // Crypto payment request
        const escrowWallet = cryptoTx.currency === 'BTC' ? ESCROW_WALLETS.BTC :
                            cryptoTx.currency === 'USDT' ? ESCROW_WALLETS.USDT_ERC20 :
                            ESCROW_WALLETS.ETH;

        cryptoWallet.pendingPayments.push({
          amount: cryptoTx.amount,
          currency: cryptoTx.currency,
          to: escrowWallet,
          timestamp: Date.now(),
          status: 'pending'
        });

        localStorage.setItem('shortfactory_crypto', JSON.stringify(cryptoWallet));

        console.log(`üí∞ Crypto payment requested: ${cryptoTx.amount} ${cryptoTx.currency}`);
        console.log(`üì¨ Send to: ${escrowWallet}`);

        // Auto-prompt MetaMask if ETH and wallet connected
        if (cryptoTx.currency === 'ETH' && cryptoWallet.connected) {
          console.log('ü¶ä Opening MetaMask...');
          // Payment will be triggered by user clicking a button or automatically
        }
      }

      if (cryptoTx.address) {
        console.log(`üì¨ Wallet address: ${cryptoTx.address}`);
      }
    }

    // Update value score and font color
    saveProfile();

    // Award points and store content based on AI response
    if (aiReply.includes('+100') || aiReply.includes('DARE POSTED')) {
      updatePoints(100);

      // Extract YouTube URL from user input
      const urlMatch = userInput.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]+)/);
      const youtubeId = urlMatch ? urlMatch[1] : null;

      const rating = extractRating(aiReply) || 8;
      const expiresAt = rating === 10 ? null : Date.now() + EXPIRATION_TIMES[rating];

      storedDares.push({
        dare: userInput,
        youtubeUrl: youtubeId ? `https://youtube.com/watch?v=${youtubeId}` : userInput,
        youtubeId: youtubeId,
        timestamp: Date.now(),
        rating: rating,
        expiresAt: expiresAt,
        userRatings: []
      });
      localStorage.setItem('shortfactory_dares', JSON.stringify(storedDares));
      updateMemoryMeters(true);
    } else if (aiReply.includes('+50') || aiReply.includes('TRUTH STORED')) {
      updatePoints(50);

      const rating = extractRating(aiReply) || 9; // Truths are valuable by default
      const expiresAt = rating === 10 ? null : Date.now() + EXPIRATION_TIMES[rating];

      storedFacts.push({
        fact: userInput,
        category: 'truth',
        timestamp: Date.now(),
        contributor: 'user_' + Date.now(),
        rating: rating,
        expiresAt: expiresAt,
        isTruth: true
      });
      localStorage.setItem('shortfactory_facts', JSON.stringify(storedFacts));
      updateMemoryMeters(true);
    } else if (aiReply.includes('+5') || aiReply.includes('JOKE STORED')) {
      updatePoints(5);

      // Extract rating and calculate expiration
      const rating = extractRating(aiReply) || 7; // Default to 7 if no rating
      const expiresAt = rating === 10 ? null : Date.now() + EXPIRATION_TIMES[rating];

      storedJokes.push({
        joke: userInput,
        timestamp: Date.now(),
        rating: rating,
        expiresAt: expiresAt
      });
      localStorage.setItem('shortfactory_jokes', JSON.stringify(storedJokes));
      updateMemoryMeters(true);
    } else if (aiReply.includes('+15') || aiReply.includes('FACT STORED')) {
      updatePoints(15);

      // Extract rating and calculate expiration
      const rating = extractRating(aiReply) || 7; // Default to 7 if no rating
      const expiresAt = rating === 10 ? null : Date.now() + EXPIRATION_TIMES[rating];

      // Store the fact
      const category = userInput.toLowerCase().includes('space') ? 'space' :
                      userInput.toLowerCase().includes('science') ? 'science' :
                      userInput.toLowerCase().includes('tech') ? 'tech' : 'general';
      storedFacts.push({
        fact: userInput,
        category: category,
        timestamp: Date.now(),
        contributor: 'user_' + Date.now(),
        rating: rating,
        expiresAt: expiresAt
      });
      localStorage.setItem('shortfactory_facts', JSON.stringify(storedFacts));
      localStorage.setItem('shortfactory_shared_fact', 'true');
      userHasShared = true;
      updateMemoryMeters(true);
    } else if (aiReply.includes('+10') || aiReply.includes('USEFUL')) {
      updatePoints(10);
    } else if (aiReply.includes('+2')) {
      updatePoints(2);
    }

    // Keep history manageable (last 10 messages)
    if (conversationHistory.length > 20) {
      conversationHistory = conversationHistory.slice(-20);
    }

    return aiReply;

  } catch (error) {
    console.error('AI Error:', error);
    return "API ERROR<br><br>TRY AGAIN";
  }
}

// Animated thinking display
function startThinking() {
  let index = 0;
  response.innerHTML = THINKING_MESSAGES[0];
  thinkingInterval = setInterval(() => {
    index = (index + 1) % THINKING_MESSAGES.length;
    response.innerHTML = THINKING_MESSAGES[index];
  }, 150); // Change every 150ms
}

function stopThinking() {
  if (thinkingInterval) {
    clearInterval(thinkingInterval);
    thinkingInterval = null;
  }
}

// Handle send
async function handleSend() {
  const text = input.value.trim();
  if (!text) return;

  // Disable input while processing
  input.disabled = true;
  send.disabled = true;

  // Show animated thinking state
  startThinking();

  try {
    const reply = await getAIResponse(text);
    stopThinking();
    response.innerHTML = reply;
    speak(reply.replace(/<br>/g, '. '));

    // Vibrate on response
    if ('vibrate' in navigator) {
      navigator.vibrate([30, 20, 30]);
    }
  } catch (error) {
    stopThinking();
    response.innerHTML = 'ERROR<br><br>RETRY';
  }

  input.value = '';
  input.disabled = false;
  send.disabled = false;
  input.focus();
}

send.onclick = handleSend;
input.addEventListener('keypress', e => {
  if (e.key === 'Enter') handleSend();
});

// Auto-focus input
input.focus();

// Cursor blinking control
const cursor = document.getElementById('cursor');
input.addEventListener('input', () => {
  cursor.style.display = input.value ? 'none' : 'inline-block';
});
input.addEventListener('focus', () => {
  cursor.style.display = input.value ? 'none' : 'inline-block';
});
input.addEventListener('blur', () => {
  cursor.style.display = 'inline-block';
});

// Chatty AI - randomly speaks every 25-200 seconds
function startChattyMode() {
  const randomDelay = (25 + Math.random() * 175) * 1000; // 25-200 seconds

  chattyTimer = setTimeout(async () => {
    if (document.hasFocus() && !input.disabled) {
      const chattyMessages = [
        { role: 'system', content: 'Send a brief, random message to the user. Options: mention how to earn HP (jokes, useful info), comment on their current HP, try to sell them something, or say something sarcastic. Keep it 1-2 lines max with <br>.' }
      ];

      try {
        const apiResponse = await fetch(XAI_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${XAI_API_KEY}`
          },
          body: JSON.stringify({
            model: 'grok-4-latest',
            messages: chattyMessages,
            temperature: 0.9,
            max_tokens: 80,
            stream: false
          })
        });

        if (apiResponse.ok) {
          const data = await apiResponse.json();
          const chatMsg = data.choices[0].message.content;
          response.innerHTML = chatMsg;
          speak(chatMsg.replace(/<br>/g, '. '));

          if ('vibrate' in navigator) {
            navigator.vibrate([20, 10, 20]);
          }
        }
      } catch (error) {
        console.log('Chatty mode error:', error);
      }
    }

    startChattyMode(); // Restart timer
  }, randomDelay);
}

// Start chatty mode after 30 seconds
setTimeout(startChattyMode, 30000);
</script>

</body>
</html>
